---
layout:     post
title:      Spring+SpringMVC+Mybatis整合
date:       2019-09-24
author:     BY
header-img: img/post-bg-BJJ.jpg
catalog: true
tags:
    - BJJ
---

www.funtl.com

注意:这是我自己的总结,详细代码看上方

# Spring   +  SpringMVC  + Mybatis

### 1,你是怎么理解Spring的?

Spring是JavaEE SE一站式轻量级框架,是为了解决企业级开发复杂度问题,系统开发过程中分为两种业务1主业务逻辑2系统级业务逻辑,主要作用就是解决主业务和系统级业务分离,将降低耦合度的方式分为两类,IoC和AOP;IoC就是对象控制权转移,从容器本身转到外部容器,有容器统一管理,是一个思想,两种常用的实现方式是依赖注入和依赖查找,依赖查找容器提供回调接口,和上下午环境的组件,DI程序运行过程中,需要调用对象,对象是由外部容器创建后传递给程序;AOP:一种编程思想,是OOP的补充,允许通过分离应用的业务逻辑与系统级服务进行开发,可以吧日志,安全,事物管理器等服务理解成一个切面,以前的服务都是写在业务逻辑代码中,这些服务被反复使用,可以剥离出来做到复用,AOP就是把这些服务剥离出来形成一个切面,将切面动态织如到业务逻辑,让业务逻辑能享受切面的服务.这样就不用把系统级业务混合到业务逻辑中了,这就是我理解的..

### 2,JUnit单元测试

用于编写和运行自动化测试的开源测试框架,测试功能的完整性,和覆盖率

#### JUnit注解

@Test 测试
@Before  在一个测试之前执行@BeforeClass 执行一次并在所以测试之前
@After 在一个测试执行后执行 @AfterClass 执行完所有执行

### 3,Log4j(Log for java)

专门给java语言用的日志框架,记录项目运行的各种日志信息,分为调试日志,运行日志,异常日志等

#### Log4j日志级别

fatal(致命的)  :系统只会输出致命的错误不会输出别的

error :系统上线后开启error只记录异常信息
debug
trace(堆栈):把所有信息都记录下来,什么时候用,调试多线程的时候

#### 为什么要对日志分级?

日志输出到控制台还是文件都会降低程序效率,,有时候运行维护,客户要求都需要进行必要的日志输出,使用syso会大大降低程序运行效率,所以进行日志分级,fatal致命的错误,error记录系统上线后记录的异常信息,这个比较常用
Slf4j简介
为java程序提供日志输出的统一接口,并不是具体的实现方案,和jdbc一样一种规则,必须搭配其他日志方案,外观模式,,帮助自己提供调用对应的日志的具体实现

### 4,Spring整合 Web

#### 1,容器初始化

启动容器的时候需要自动装载 ApplicationContext,Spring提供了ContextLoaderListener,就是为了自动装配ApplicationContext的配置信息

#### 2,Bean的作用域

scope=singketon:单例模式 系统中只有一个实例 该Bean在容器被创建的时候就装配好了
scope=protottype:原形模式 每次使用getBean方法都有一个新的实例
request 每次http请求都将会产生一个不同的Bean实例
session 对每个不同的session,都产生一个不同的Bean

#### 3,基于注解的依赖注入

核心注解:
@Component:需要在类上注解,注解的value属性用于指定bean的id值
@Repository:用于对Dao实现类进行注解
@Service:用于对service的实现类注解
@Controller:用于对Controller实现类进行注解

#### 4,注解与xml的区别?

项目运行有编译运行打包的过程,使用注解改代码需要重新编译代码
xml项目服务器已重启就好了 

### 5,什么是SpringMVC?

是spring框架的一部分,提供了MVC(模型,视图,控制器)架构和用于开发灵活和松耦合的web应用程序的组件,让应用程序不同的方面(输入逻辑,业务逻辑和UI逻辑)分离,同时提供这些元素之间的松耦合

#### 1,核心组件 DisoatcherServlet 处理流程?

处理所有HTTP请求和响应,浏览器端发起一个请求,先发送到dispatcherServlet接收到用户的请求,会查询HandLerMapping会找到你具体要调用的是谁,然后跳转到控制器,Controller接收并根据GET或POST方法调用响应的服务方法,方法基于定义的逻辑设置模型数据并把视图名称给Model and什么模型,把要返回的视图名和数据给dispatcherServlet,dispatcherServlet将从 ViewResolver 获取请求的定义视图,当视图完成dispatcherServlet将模型数据传递到最终的视图在浏览器上呈现;

#### 老师的意思

用户请求的时候发给了DisoatcherServlet ,DisoatcherServlet 通过HandLerMapping找到对应的需要调用的控制器里面的那个方法,做完控制器的业务逻辑之后会告诉DisoatcherServlet 我会返回到哪个页面,然后DisoatcherServlet 通过视图解析器找到我给他的视图文件的位置,并将结果返回给用户

#### SpringMVC的注解

@Controller:用于处理分发器的请求,进过业务处理层之后封装成一个Model,然后返回给对应的views
@RequestMapping():处理请求地址映射的注解

#### SpringMVC拦截器 

类似于Servlet的过滤器,用于对处理器进行预处理和后处理

#### 拦截器常用场景:

日志记录:以便进行信息监控,信息统计,计算机Pv等
权限检查:有没有访问权限,面向切面了
性能监控:
读取Cookie
实现拦截器需要实现HandlerInterceptor,接口定义了三个接口,
preHandle()请求之前干什么 验证有没有权限登录前置条件,执行完后postHandle();之后的一系列操作后置条件
afterCompletion()整个请求都完成之后,比如说做一些释放资源操作,