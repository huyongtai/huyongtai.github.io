---
layout:     post
title:      Java面试题
subtitle:   
date:       2019-09-22
author:     BY
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - iOS
---


## 前言

自己整理的,和别人整理的从头开始

## 一  java基础

### 1,集合

#### **1,Collection和Collections的区别**?

Collection

​	是集合类的上级接口，继承他的接口主要有Set和List

Collections

​	是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

#### 2,List、Map、Set三个接口，存取元素时，各有什么特点?

List 接口存储一组不唯一，有序（插入顺序）的对象

Set 接口存储一组唯一，无序的对象 

Map接口存储一组键值对象，提供key到value的映射

#### 3,Hashtable和HashMap的异同

主要区别 Hashtable继承Dictionary类，HashMap实现Map接口

 Hashtable线程安全，HashMap线程非安全 

Hashtable不允许null值，HashMap允许null值

#### 4,说出ArrayList,Vector,LinkedList的存储性能和特性

ArrayList :底层是动态数组的数据结构,从内存中连续开辟内存空间,以为是地址连续,所以查询快增删慢

LinkedList:链表的数据结构,内存地址是任意的,不用连续开辟空间,所以他的增删慢,查询快

vector:一组动态数组,内部方法都加了同步锁,所以线程安全

hashMap:是一个散列桶:采用了链表和数组的数据结构,内容存储的是键值对,不允许重复,可以为null值,线程不安全

hashTable:内部也是一个散列桶,不允许null值 线程安全

HashSet:接口set的实现类,存储数据具有无序性,不允许重复,线程不安全

TreeSet:具有基本的数据比较功能,存储值的顺序自然排序,字符串按Ascll值进行排序

### 2,多线程

#### **1,创建线程的方式及实现**

**一、)继承** **Thread** **类创建线程类** 

（1）定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体 

就代表了线程要完成的任务。因此把 run()方法称为执行体。 

（2）创建 Thread 子类的实例，即创建了线程对象。 

（3）调用线程对象的 start()方法来启动该线程。 

**二、通过** **Runnable** **接口创建线程类** 

（1）定义 runnable 接口的实现类，并重写该接口的 run()方法，该 run()方法 

的方法体同样是该线程的线程执行体。 

（2）创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创 

建 Thread 对象，该 Thread 对象才是真正的线程对象。 

（3）调用线程对象的 start()方法来启动该线程。 

**三、通过** **Callable** **和** **Future** **创建线程** 

（1）创建 Callable 接口的实现类，并实现 call()方法，该 call()方法将作为线 

程执行体，并且有返回值。 

（2）创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象， 

该 FutureTask 对象封装了该 Callable 对象的 call()方法的返回值。 

（3）使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 

（4）调用 FutureTask 对象的 get()方法来获得子线程执行结束后的返回值 

#### **2,线程池的几种方式**

为什么要用线程池:		减少创建和销毁的次数，每个工作线程都可以被重复利用，可执行多个任务

**newFixedThreadPool(int nThreads)** 

创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达 

到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而 

结束时，线程池会补充一个新的线程 

**newCachedThreadPool()** 

7创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收 

空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何 

限制 

**newSingleThreadExecutor()** 

这是一个单线程的 Executor，它创建单个工作线程来执行任务，如果这个线 

程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的 

顺序来串行执行 

**newScheduledThreadPool(int corePoolSize)** 

创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 

于 Timer。

#### 3,**线程的生命周期**

新建状态——实例化一个Thread对象

就绪状态——线程启动,等待分配给cpu的时间片

运行状态——线程获得CPU资源,执行任务

堵塞状态——某种原因让CPU暂停,睡眠sleep(),等待wait();

死亡——-线程执行完毕,或者被杀死,就会进入死亡状态

#### 4,**悲观锁 乐观锁**

每次获取数据的时候，都不用担心数据被修改，所以每次获取数据的时候都 

不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果 

数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进 

行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。 

乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数 

据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新 

获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

悲观锁   sync

#### 5,**单例模式**

单例模式有两种懒汉和恶汉模式: 恶汉的特点:就是立即加载,就是使用类的时候就已经把对象创建好了

懒汉的特点:延迟加载,就是调用get()方法时实例才会被工厂创建

#### **6,共享锁和排他锁?**

共享锁:与读操作相关的锁,如select语句,事物a对数据b加上共享锁后,其他abcd只能对a加共享锁,只能读数据不能改数据

排他锁:写操作相关的锁,用于数据库修改操作,增删改,确保不会同一资源进行多重更新,即能读数据也能修改数据

#### 7,**ThreadLocal**

主要用于存储当前线程上下文的变量信息,它可保证到存储的数据只能被当前线程读取到,线程之间不会有影响!

ThreadLocal应用场景

1,数据库事务

对执行数据库的事务函数进行拦截,把连接存到ThreadLocal中,可以保证到只使用一次连接,减少代码冗余,减少创建连接到开销

2,拦截器

登陆的时候拦截用户信息,放到ThreadLocal中,用的时候读取

#### 8,**禁止重排**

三个特性volatie

可见性:b线程能马上看到a线程更改的信息

原子性:多个操作,要么全部执行,过程中不会被任何因素打断,要么都不执行

有序性:执行顺序按代码先后顺序执行

### 3,IO

#### 1,**什么是** **IO** **流？**

它是一种数据的流从源头流到目的地。比如文件拷贝，输入流和输出流都包 

括了。输入流从文件中读取数据存储到进程(process)中，输出流从进程中读取数 

据然后写入到目标文件。 

#### 2,**字节流和字符流的区别**

字节流在 JDK1.0 中就被引进了，用于操作包含 ASCII 字符的文件。JAVA 

也支持其他的字符如 Unicode，为了读取包含 Unicode 字符的文件，JAVA 语言 

设计者在 JDK1.1 中引入了字符流。ASCII 作为 Unicode 的子集，对于英语字符 

的文件，可以使用字节流也可以使用字符流。 

#### 3,**什么是** **Java** **的反射**

JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

#### 4,序列化和反序列化的概念

​    序列化：把对象转换为字节序列的过程称为对象的序列化。

​	反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

## 二,Javaweb

#### 1,**get请求和post请求的区别**?

get地址栏显示路径和参数用？号分隔，参数名和值用=号分隔，多个参数用&号，

post地址栏不显示，http是明文协议，所以get和post安全性差，

最大区别是post传输的数据量较大，get传递数据量有限

#### **2,session** **与** **cookie** **区别**

获取cookie的过程：客户端发起请求的时候request携带cookie给服务器

Cookie减轻了服务器内存占用器的压力，数据安全性不高，因为数据在客户端本地，存储数据类型只能说String

Session:数据存放在服务器端，数据安全性较高。存储的类型是object，因为数据存在服务器端，所以内存占用率较高

#### 3,**Session在请求与响应得运行机制**

首次请求，会在服务端创建sessionid，存到cookie里返回给浏览器,如果多次请求浏览器会携带cookie里的sessionid给服务器，服务器会进行匹配，首次访问服务端的时候，生成1个Map对象，key就是唯一的sessionid,值就是session存放得值，进行响应，再次访问得时候，携带cookie到服务端，把服务端的sessionid和携带的sessionid进行匹配，然后进行后期处理

#### 4,**什么是jdbc(java database Connectivity java数据库连接)**

​	是sun为统一操作数据库发布的一个标准，为这个标准定义了一套Java操作数据库的API可以执行SQL语句，是Java语言定义的接口和类组成，是Java语言和数据库通信的桥梁是众多ORM框架的基础，hiberbate,mybatis等框架内部原理都是基于jdbc的

##### **1,使用JDBC的步骤**

​    加载JDBC驱动程序 →

​    建立数据库连接Connection →

​	创建执行SQL的语句Statement →

​	处理执行结果ResultSet → 释放资源

#### **5,MVC** **设计思想.分层开发**

**Model:**业务模型层，service业务类实现，

**View:**视图层，显示用户界面html，jsp

**Controller:**控制层：控制软件大方向的执行流程，servlet进行实现

#### 6,**什么是Ajax**

现客户端与服务器交换数据 并更新部分数据,就是局部刷新

Ahax api的核心是XMLHttpRequest对象,该对象支持异步请求

就是在使用xmlHTTPrequest对象是服务器发出请求并处理响应,同时

执行后面的程序代码,不阻塞后面的程序代码,提升用户体验

#### 1ajax的过程

使用ajax的话浏览器先把请求发送到XMLHttpRequest异步对象中,异步对象对请求进行封装,再发给服务器,服务器不是以转发的方式响应,而是以流的方式把数据返回给浏览器,不听监听服务器的状态

#### 7,**ajax** **请求时，如何解释接收 **json** **数据**

使用 eval() 或者 JSON.parse() 鉴于安全性考虑，推荐使用 JSON.parse()更 

靠谱，对数据的安全性更好.

#### 8,设计模式

**单例模式**

保证类在内存中只能有一个对象

单例模式有两种懒汉和恶汉模式: 恶汉的特点:就是立即加载,就是使用类的时候就已经把对象创建好了懒汉的特点:延迟加载,就是调用get()方法时实例才会被工厂创建

**工厂模式**

用一些方法隐藏了对象的细节,只需要告诉工厂所需的类型就行,比如说连接数据库工厂,把连接步骤写到一个类中,需要的连接数据库,不需要的时候关闭时候调用

#### 8,九大内置对象

**1 request 对象：** 

代表的是来自客户端的请求，例如我们在 FORM 表单中填写的信息等，是 

最常用的对象。客户端的请求信息被封装在 request 对象中，通过它才能了解 

到客户的需求，然后做出响应。它是 HttpServletRequest 类的实例。作用域为 

request(用户请求期）。 

**2 response 对象：** 

对象代表的是对客户端的响应，也就是说可以通过 response 对象来组织 

发送到客户端的数据。但是由于组织方式比较底层，所以不建议普通读者使 

2021 

用，需要向客户端发送文字时直接使用。它是 HttpServletResponse 类的实 

例。作用域为 page（页面执行期）。 

**3 session 对象：** 

指的是客户端与服务器的一次会话，从客户连到服务器的一个 

WebApplication 开始，直到客户端与服务器断开连接为止。它是 HttpSession 

类的实例。作用域 session(会话期—）。 

**4 out 对象 ：** 

out 对象是 JspWriter 类的实例,是向客户端输出内容常用的对象 。作用域 

为 page（页面执行期） 

**5 page 对象：** 

page 对象就是指向当前 JSP 页面本身，有点象类中的 this 指针，它是 

java.lang.Object 类的实例 。“page” 对象代表了正在运行的由 JSP 文件产生 

的类对象，不建议一般读者使用。 作用域 page 

**6 application 对象：** 

实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直 

到服务器的关闭，在此期间，此对象将一直存在；这样在用户的前后连接或不 

同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对 

象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了 

application 对象的生命。它是 ServletContext 类的实例。作用域 application 

**7 pageContext 对象：** 

提供了对 JSP 页面内所有的对象及名字空间的访问，也就是说他可以访问 

到本页所在的 SESSION，也可以取本页面所在的 application 的某一属性值， 

他相当于页面中所有功能的集大成者，它的本类名也叫 pageContext。用 

域 Pageconfig 对象 

**8 config 对象：** 

config 对象是在一个 Servlet 初始化时，JSP 引擎向它传递信息用的，此 

信息包括 Servlet 初始化时所要用到的参数（通过属性名和属性值构成）以及 

服务器的有关信息（通过传递一个 ServletContext 对象）。作用域 Page 

**9 exception 对象：** 

是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对 

象。如果一个 JSP 页面要应用此对象，就必须把 isErrorPage 设为 true，否则 

无法编译。他实际上是 java.lang.Throwable 的对象.作用域 page

### 三,数据库

**1 ,Sql** **之连接查询**

**外连接：** 

1） 左连接（左外连接）以左表为基准进行查询,左表数据会全部显示出来,右表 

如果和左表匹配 

的数据则显示相应字段的数据,如果不匹配,则显示为 NULL; 

2） 右连接（右外连接）以右表为基准进行查询,右表数据会全部显示出来,右表 

如果和左表匹配的数据则显示相应字段的数据,如果不匹配,则显示为 NULL; 

3） 全连接就是先以左表进行左外连接，然后以右表进行右外连接。 

**内连接：** 

显示表之间有连接匹配的所有行。 

**2,Sql** **之聚合函数：**

聚合函数是对一组值执行计算并返回单一的值的函数，它经常与 SELECT 

语句的 GROUP BY 子句一同使用。 

1).AVG 返回指定组中的平均值，空值被忽略； COUNT 返回指定组中 

项目的数量。 

例：select prd_no,avg(qty) from sales group by prd_no 

2). MAX 返回指定数据的最大值；MIN 返回指定数据的最小值；SUM  

返回指定数据的和，只能用于数字列，空值被忽略。 

例：select prd_no,max(qty) from sales group by prd_no  

3）使用 group by 子句对数据进行分组；对 group by 子句形成的组运行 

聚集函数计算每一组的值；最后用 having 子句去掉不符合条件的组；having 子 

句中的每一个元素也必须出现在 select 列表中。有些数据库例外，如 oracle. 

例：select prd_no,max(qty) from sales group by prd_no having  

prd_no>10

**3 SQL Select** **语句完整的执行顺序**

from--->where--->group by--->having--->计算所有的表达式--->order by-- 

->select 输出

**4,什么是存储过程？它有什么优点？**

存储过程是事先经过编译并存储在数据库中的一段[SQL语句](https://www.baidu.com/s?wd=SQL语句&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。

优点：

1、重复使用：存储过程可以重复使用，从而可以减少数据库开发人员的工作量。

2、减少网络流量：存储过程位于服务器上，调用的时候只需要传递存储过程的名称以及参数就可以了，因此降低了网络传输的数据量。

3、安全性：参数化的存储过程可以防止SQL注入式攻击，而且可以将Grant、Deny以及Revoke权限应用于存储过程。

存储过程的缺点：

1、更改比较繁琐：如果更改范围大到需要对输入存储过程的参数进行更改，或者要更改由其返回的数据，则仍需要更新程序集中的代码以添加参数、更新 GetValue() 调用，等等，这时候估计比较繁琐。

**5,Mysql** **性能优化举例**

**1） 当只要一行数据时使用 LIMIT** 

当你查询表的有些时候，你已经知道结果只会有一条结果，在这种情况下， 

加上 LIMIT 1 可以增加性能。这样一样，MySQL 数据库引擎会在找到一条 

数据后停止搜索，而不是继续往后查少下一条符合记录的数据。 

**2）选择正确的存储引擎** 

在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。 MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是 很好。甚至你只是需要 update 一个字段，整个表都会被锁起来，而别的进程， 就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT  COUNT(*) 这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会 比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。 并且，他还支持更多的高级应用，比如：事务。 

**3）用 Not Exists 代替 Not In** 

Not Exists 允许用户使用相关子查询已排除一个表中能够与另一个表 成功连接的所有记录。Not Exists 用到了连接，能够发挥已经建好的索引的作用， 而 Not In 不能使用索引。Not In 是最慢的方式，要同每条记录比较，在数据量比 较大的查询中不建议使用这种方式。 Select a.mobileid from Log_user a where not exists (select b.mobileid from  magazineitem b where b.mobileid=a.mobileid); 

**4）对操作符的优化 尽量不采用不利用索引的操作符** 

如：in ，not in ， is nul， is not null，<>等 某个字段你总要会经常用来做搜索，为其建立索引： Mysql 中可以使用 alter table 语句来为表中的字段添加索引的基本语法 是： ALTER TABLE <表名> ADD INDEX (<字段>); 例：mysql> alter table test add index(t_name); 

**5)mysql 分库分表：** 

单库多表:用户数量增加,user数据量会越来越大,当数据量达到一定程度的时候,user表查询会渐渐变慢会影响DB的性能,可以将user表进行水平切分,结构一模一样