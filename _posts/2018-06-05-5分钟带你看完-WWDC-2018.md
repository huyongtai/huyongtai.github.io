---
layout:     post
title:      JAVA基础总结
subtitle:   WWDC 2019 Keynote 全记录
date:       2019-06-05
author:     BY
header-img: img/post-bg-cook.jpg
catalog: true
tags:
    - iOS
---

## 前言

哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈


## 集合、多线程、JDBC、Servlet

Collection和Collections的区别

### Collection

​		是集合类的上级接口，继承他的接口主要有Set和List

### Collections

​		是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

### 1、说出ArrayList,Vector,LinkedList的存储性能和特性

​		ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差。而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，索引就变慢了，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。

 LinkedList也是线程不安全的，LinkedList提供了一些方法，使得LinkedList可以被当作堆栈和队列来使用。

### 2、List、Map、Set三个接口，存取元素时，各有什么特点?

​	List 接口存储一组不唯一，有序（插入顺序）的对象
​	Set 接口存储一组唯一，无序的对象 
​	Map接口存储一组键值对象，提供key到value的映射



### 3、集合框架有何好处？ 

​	集合弥补了数组的缺陷，他比数组更灵活更实用，可大大提高软件的开发效率，而且不同的集合可使用与不同场合.

### 4、常用集合

ArrayList :底层是动态数组的数据结构,从内存中连续开辟内存空间,以为是地址连续,所以查询快增删慢

LinkedList:链表的数据结构,内存地址是任意的,不用连续开辟空间,所以他的增删慢,查询快

vector:一组动态数组,内部方法都加了同步锁,所以线程安全

hashMap:是一个散列桶:采用了链表和数组的数据结构,内容存储的是键值对,不允许重复,可以为null值,线程不安全

hashTable:内部也是一个散列桶,不允许null值 线程安全

HashSet:接口set的实现类,存储数据具有无序性,不允许重复,线程不安全

TreeSet:具有基本的数据比较功能,存储值的顺序自然排序,字符串按Ascll值进行排序

### 5、Hashtable和HashMap的异同

主要区别
		Hashtable继承Dictionary类，HashMap实现Map接口
		Hashtable线程安全，HashMap线程非安全
		Hashtable不允许null值，HashMap允许null值

### 6,多线程

**1、什么是线程**
	线程是CPU调度和分派的基本单位，进程中执行运算的最小单位，可完成一个独立的顺序控制流程

**2、什么是进程**
	进程是应用程序的执行实例，有独立的内存空间和系统资源

**3、什么是多线程**
	如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为“多线程”
	多个线程交替占用CPU资源，而非真正的并行执行

**4、多线程好处**
	充分利用CPU的资源
	简化编程模型
	带来良好的用户体验

**5、什么是主线程**
	main()方法即为主线程入口
	产生其他子线程的线程
	必须最后完成执行，因为它执行各种关闭动作

**6、创建线程的两种方式**

实现Runnable接口,继承Thread类

**7、什么是线程池**

​		相当于一个容器,把若干个线程放入该容器,需要的时候取出,不用自行创建,使用完毕后不需要销毁,减少了创建和销毁线程的开销

**8、五种状态**

新建状态------实例化一个Thread对象

就绪状态------线程启动,等待分配给cpu的时间片

运行状态------线程获得CPU资源,执行任务

堵塞状态------某种原因让CPU暂停,睡眠sleep(),等待wait();

死亡-------线程执行完毕,或者被杀死,就会进入死亡状态

**9、join(),yield(),sleep()的区别**

join();先执行,当前线程暂停,等待其他几个线程执行完毕在执行

yield();礼让,让优先级高的获得运行机会,当前线程就会进入就绪状态

sleep();休眠,让当前线程暂时休眠,锁不释放,其他线程不能执行

**10、run和start的区别**

run();只有主线程一条执行路径

start();多条执行路径,主线程和子线程交替执行

**11,为什么要线程同步**

多个线程操作同一共享资源,将引发数据不安全问题

**12,ThreadLocal 简介**

主要用于存储当前线程上下文的变量信息,它可保证到存储的数据只能被当前线程读取到,线程之间不会有影响!

ThreadLocal应用场景

1,数据库事务

对执行数据库的事务函数进行拦截,把连接存到ThreadLocal中,可以保证到只使用一次连接,减少代码冗余,减少创建连接到开销

2,拦截器

登陆的时候拦截用户信息,放到ThreadLocal中,用的时候读取

**13,禁止重排**

三个特性

可见性:b线程能马上看到a线程更改的信息

原子性:多个操作,要么全部执行,过程中不会被任何因素打断,要么都不执行

有序性:执行顺序按代码先后顺序执行

**14、synchronized  同步锁，具有排他性**
	多个线程操作同一共享资源时，将引发数据不安全问题
	多个线程同时操作共享数据
	加入关键字，以排队的方式处理，先判断有没有被上锁
	必须等其他线程运行完毕才可以执行

## 7, JDBC

**1,什么是jdbc(java  database  Connectivity  java数据库连接)**

​			是sun为统一操作数据库发布的一个标准，为这个标准定义了一套Java操作数据库的API可以执行SQL语句，是Java语言定义的接口和类组成，是Java语言和数据库通信的桥梁

是众多ORM框架的基础，hiberbate,mybatis等框架内部原理都是基于jdbc的

**2，为什么要使用jdbc**

​		有多个数据库厂商，程序员就要些多种api造成了很大的学习成本，

只需要jdbc中的api就能操作不同的数据库

**3,使用JDBC的步骤**

​	  加载JDBC驱动程序 →	

 	建立数据库连接Connection →

​	 创建执行SQL的语句Statement →

​	 处理执行结果ResultSet → 释放资源

**4,接口介绍**

Driver:第三方厂商将驱动注册到jvm中,第三方就要实现driver的接口

Connection:连接数据库

Statement  执行SQL语句,安全性不高,有损软件的安全性

PreparedStatement:Statement的子类,提高了SQL语句的安全性,方便开发,使用问号占位传入参数值,预编译机制增加运行效率

ResultSet: 返回结果集

**5,什么是预编译和缓存**

预编译：把sql语句放到服务器上，服务器对mysql进行效验

缓存，对ps对象进行缓存,

**6,复习静态代码块:**

实例化一个类时，该类的静态代码块会自动执行

**7,什么是dto，entity，dao**

数据传输数据，在不同的类中进行数据交换,

实体类：对应表中的列,

dao的作用;数据访问对象，封装对数据库操作的代码，便于后期的代码的维护与排错

## 8,Servlet

> 关键词：ORM映射原理 mybatis   :对象关系映射一个类对应一个表，一个实例对应表中的一行

**1,什么是数据源和连接池**

Sun公司提供的规范，如果多家公司都有连接工场，程序员就要写好多api，只要实现了datasource,就可以很方便的进行连接，更规范易于维护HikariCO框架预先将很多个conn对象放入一个内存区中，比如说一个集合，一个大型的网站，操作数据库的次数非常多，连接池就不用新建了只需要从内存中取得创建好的conn对象就好，大大增加运行效率，在使用。Close()方法时，关闭客户端与与连接池的conn,然后将conn标记为空闲状态，这样就实现了conn的复用，连接池里的conn没有和数据库断开增加与数据库通讯的效率

**2,生命周期**

实例化

初始化阶段  调用init()

响应客户请求阶段。调用service()方法，由service()方法根据提交的方式选择执行doGet()或者doPost()方法

终止阶段调用destroy()方法

**3,执行流程**

容器启动后，会读取webapp下的web.xml文件，根据别名找到路径，然后通过反射对servlet进行实例化

装饰者模式：动态给一个对象添加额外的功能

**4,get请求和post请求的区别**

get地址栏显示路径和参数用？号分隔，参数名和值用=号分隔，多个参数用&号，

post地址栏不显示，http是明文协议，所以get和post安全性差，

最大区别是post传输的数据量较大，get传递数据量有限

**5,请求与响应 模型**

在web开发中，从客户端发起请求到服务器端获取数据的过程；

请求request 就是从客户端到服务器

响应response 服务器到到客户端

## 9,cookie

**1,什么是cookie**

是在浏览器客户端保存数据的一种方案，保存在用户的个人电脑上

**2，创建cookie的两种方式**

客户端创建

服务端创建：执行servlet把cookie放到response，客户端接收并保存

获取cookie的过程：客户端发起请求的时候request携带cookie给服务器

**cookie和session的区别**

Cookie减轻了服务器内存占用器的压力，数据安全性不高，因为数据在客户端本地，存储数据类型只能说String

Session:数据存放在服务器端，数据安全性较高。存储的类型是object，因为数据存在服务器端，所以内存占用率较高

**Session在请求与响应得运行机制**

首次请求，会在服务端创建sessionid，存到cookie里返回给浏览器,如果多次请求浏览器会携带cookie里的sessionid给服务器，服务器会进行匹配，首次访问服务端的时候，生成1个Map对象，key就是唯一的sessionid,值就是session存放得值，进行响应，再次访问得时候，携带cookie到服务端，把服务端的sessionid和携带的sessionid进行匹配，然后进行后期处理

### 10,MVC(Model,View,Controller)分层开发

**Model:**业务模型层，service业务类实现，

**View:**视图层，显示用户界面html，jsp

**Controller:**控制层：控制软件大方向的执行流程，servlet进行实现

**1,request作用域**

Request.setAttrbute()存储数据发生response时失效，

request的私有数据原理是当前线程拥有自己的request对象

**2,Session的作用域**

取决于web容器指定的超时时间或者手写.inavlidate()删除，

sesion的私有数据在多次会话能被访问，原理是浏览器拥有自己的sessionid，根据id到服务器取得数据

**3,ServletContext作用域**

ServletContext的数据是共享的，直到tomcat服务器关闭才销毁原理是所有请求都访问同一个ApplicationContext对象中的map

#### **过滤器Filter**

**1,什么是过滤器**

小型的web组件，拦截请求和响应查看，提取，或者以某种方式操作正在客户端和服务端之间交换的数据。实际上也是一种预处理，一般用在权限控制web开发中检查当前用户是否有效等!

生命周期

实例化    初始化   工作   销毁

**2监听Listener **

监听Listener 监视系统中部分组件的运行状态,接收发生的事件的通知,可以在监听中进行处理,比如实现日志记录,数据校验等.

### **11,Ajax**

**1,什么是Ajax**

实现客户端与服务器交换数据 并更新部分数据,就是局部刷新

Ahax api的核心是XMLHttpRequest对象,该对象支持异步请求

就是在使用xmlHTTPrequest对象是服务器发出请求并处理响应,同时

执行后面的程序代码,不阻塞后面的程序代码,提升用户体验

**2,为什么需要Ajax?**

用户向服务器发送请求,只更新一点内容,都会刷新整个页面,用户操作页面被中断

**3,XMLHttpRequest的工作原理**

使用ajax的话浏览器先把请求发送到XMLHttpRequest异步对象中,异步对象对请求进行封装,再发给服务器,服务器不是以转发的方式响应,而是以流的方式把数据返回给浏览器,不听监听服务器的状态

## 结语

​	**自己看的有点不全面。**
